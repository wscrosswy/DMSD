/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Thu Apr 18 2019 15:39:58 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase.
 * To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of JSONOutput.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin JSONOutput.
     * @constructor
     */
    function JSONOutput() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.jsonOutput = {};
        this.nodeData = {};
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    JSONOutput.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    JSONOutput.prototype = Object.create(PluginBase.prototype);
    JSONOutput.prototype.constructor = JSONOutput;


    JSONOutput.prototype.buildNodeData = function(path, name, metaType, basePath, parentPath, attributeNames, attributes, srcPath, dstPath,referenceNames,references){
        var self = this;
        var i =0;
        self.nodeData[path]={};
        self.nodeData[path].Path = path;
        self.nodeData[path].Name = name;
        self.nodeData[path].MetaType = metaType;
        self.nodeData[path].BasePath = basePath;
        self.nodeData[path].ParentPath = parentPath;
        self.nodeData[path].Attributes  = {};
        self.nodeData[path].References  = {};
        if (srcPath && dstPath)
        {
            self.nodeData[path].SrcPath = srcPath;
            self.nodeData[path].DstPath = dstPath;
        }

        for(i=0; i !== attributeNames.length; i+=1)
        {
            self.nodeData[path].Attributes[attributeNames[i]] = attributes[attributeNames[i]];
        }


        for(i=0; i !== referenceNames.length; i+=1)
        {
            self.nodeData[path].References[referenceNames[i]] = references[referenceNames[i]];
        }

    };
    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    JSONOutput.prototype.main = function (callback) {
        var self = this;
        var activeNode = this.activeNode,
            core = this.core,
            logger = this.logger;

        var activenodename = self.core.getAttribute(self.activeNode, 'name');
        var dt = new Date();
        var filename = 'JSON_Output_'+activenodename+'-'+ dt.valueOf() +'.json';


        // WebGME api returns strings with special characters already escaped (eg. "My \"string\"")
        // JSON.stringify removes these escape characters.
        // eg. "My \"string\"" becomes "My "string"", which is not valid JSON
        // Need replacer function to escape the escape characters.  (eg. "My \"string\"" -> "My \\"string\\"")
        function specialCharacterReplacer(key, val) {
            if (typeof(val) !== 'string') { return val; }
            return val
                .replace(/[\\]/g, '\\\\')
                //.replace(/[\/]/g, '\\/')
                .replace(/[\b]/g, '\\b')
                .replace(/[\f]/g, '\\f')
                .replace(/[\n]/g, '\\n')
                .replace(/[\r]/g, '\\r')
                .replace(/[\t]/g, '\\t')
                .replace(/[\"]/g, '\\"')
                ;
        }

        function atNode(node, done) {
            try {
                var metaNode = core.getBaseType(node),
                    name = core.getAttribute(node, 'name'),
                    path = core.getPath(node),
                    attributeNames = core.getAttributeNames(node),
                    referenceNames = core.getPointerNames(node),
                    isconnection = core.isConnection(node),
                    base = core.getBase(node),
                    parent = core.getParent(node),
                    basePath='/.',
                    metaType='',
                    srcPath='',
                    dstPath='',
                    attributes={},
                    references={},
                    parentPath='/.',
                    i;

                if (metaNode) {
                    metaType = core.getAttribute(metaNode, 'name');
                } else {
                    // The root-node does not have a meta node.
                    metaType = 'ROOTNode';
                    path='/.';
                }

                if (base){
                    basePath = core.getPath(base);
                }

                if (parent){
                    parentPath = core.getPath(parent);
                }
                if (parentPath === ''){
                    parentPath = '/.';
                }

                i=0;
                attributes={};
                for(i=0; i !== attributeNames.length; i+=1)
                {
                    attributes[attributeNames[i]] = core.getAttribute(node,attributeNames[i]);

                }
                i=0;
                references={};
                for(i = 0; i !== referenceNames.length; i+=1)
                {
                    references[referenceNames[i]] = core.getPointerPath(node,referenceNames[i]);

                }

                if (isconnection)
                {
                    srcPath = self.core.getPointerPath(node, 'src');
                    dstPath = self.core.getPointerPath(node, 'dst');
                }
                logger.info('[', path, '] - ', name, 'is of type', metaType);
                self.buildNodeData(path, name, metaType, basePath, parentPath, attributeNames, attributes, srcPath, dstPath,referenceNames,references);
                done();
            } catch (err) {
                done(err);
            }
        }

        core.traverse(activeNode, null, atNode, function(err){
            if (!err)
            {
                self.jsonOutput = JSON.stringify(self.nodeData, specialCharacterReplacer, 2);
                var artifact = self.blobClient.createArtifact('JSONOutput');
                var content = {};
                content[filename] =  self.jsonOutput;
                // Upload the files to server.

                artifact.addFiles(content, function (err) {
                    if (err) {
                        callback(err, self.result);
                        return;
                    }
                    // Save the artifact (uploads meta data about the file(s) within in it).
                    artifact.save(function (err, hash) {
                        if (err) {
                            callback(err, self.result);
                            return;
                        }
                        // Add a link to the artifact to the plugin-result.
                        self.result.addArtifact(hash);

                    });
                });

                self.result.setSuccess(true);
            }

            // A plugin should always return with a result, in iCore it's optional and
            // used only to display the plugin result dialog.
            callback(err, self.result);
        });
    };

    return JSONOutput;
});